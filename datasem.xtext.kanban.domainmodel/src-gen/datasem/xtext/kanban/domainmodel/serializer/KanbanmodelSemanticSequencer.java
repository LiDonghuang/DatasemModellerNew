/*
 * generated by Xtext
 */
package datasem.xtext.kanban.domainmodel.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import datasem.xtext.kanban.domainmodel.kanbanmodel.AbstractParameter;
import datasem.xtext.kanban.domainmodel.kanbanmodel.AgentRoleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Asset;
import datasem.xtext.kanban.domainmodel.kanbanmodel.CausalTrigger;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ClassOfService;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Condition;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ConditionType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Distribution;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Event;
import datasem.xtext.kanban.domainmodel.kanbanmodel.EventType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ExperimentModel;
import datasem.xtext.kanban.domainmodel.kanbanmodel.GovernanceStrategy;
import datasem.xtext.kanban.domainmodel.kanbanmodel.KanbanmodelPackage;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Mechanism;
import datasem.xtext.kanban.domainmodel.kanbanmodel.MechanismAttribute;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ModelBuilder;
import datasem.xtext.kanban.domainmodel.kanbanmodel.NumExpression;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Operator;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ProcessAttribute;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ProcessModel;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ResourceAllocation;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ResourceAllocationRuleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ResourceOutsourcing;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ResourceOutsourcingRuleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Service;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ServiceProvider;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Skill;
import datasem.xtext.kanban.domainmodel.kanbanmodel.SystemLibraries;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Transition;
import datasem.xtext.kanban.domainmodel.kanbanmodel.TransitionType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.UserLibraries;
import datasem.xtext.kanban.domainmodel.kanbanmodel.ValueFunction;
import datasem.xtext.kanban.domainmodel.kanbanmodel.Variable;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WIAcceptance;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WIAcceptanceRuleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WIAssignment;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WIAssignmentRuleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WINReplication;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WISelection;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WISelectionRuleType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WorkItem;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WorkItemNetwork;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WorkItemType;
import datasem.xtext.kanban.domainmodel.kanbanmodel.WorkSource;
import datasem.xtext.kanban.domainmodel.services.KanbanmodelGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KanbanmodelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KanbanmodelGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == KanbanmodelPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case KanbanmodelPackage.ABSTRACT_PARAMETER:
				sequence_AbstractParameter(context, (AbstractParameter) semanticObject); 
				return; 
			case KanbanmodelPackage.AGENT_ROLE_TYPE:
				sequence_AgentRoleType(context, (AgentRoleType) semanticObject); 
				return; 
			case KanbanmodelPackage.ASSET:
				sequence_Asset(context, (Asset) semanticObject); 
				return; 
			case KanbanmodelPackage.CAUSAL_TRIGGER:
				sequence_CausalTrigger(context, (CausalTrigger) semanticObject); 
				return; 
			case KanbanmodelPackage.CLASS_OF_SERVICE:
				sequence_ClassOfService(context, (ClassOfService) semanticObject); 
				return; 
			case KanbanmodelPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case KanbanmodelPackage.CONDITION_TYPE:
				sequence_ConditionType(context, (ConditionType) semanticObject); 
				return; 
			case KanbanmodelPackage.DISTRIBUTION:
				sequence_Distribution(context, (Distribution) semanticObject); 
				return; 
			case KanbanmodelPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case KanbanmodelPackage.EVENT_TYPE:
				sequence_EventType(context, (EventType) semanticObject); 
				return; 
			case KanbanmodelPackage.EXPERIMENT_MODEL:
				sequence_ExperimentModel(context, (ExperimentModel) semanticObject); 
				return; 
			case KanbanmodelPackage.GOVERNANCE_STRATEGY:
				sequence_GovernanceStrategy(context, (GovernanceStrategy) semanticObject); 
				return; 
			case KanbanmodelPackage.MECHANISM:
				sequence_Mechanism(context, (Mechanism) semanticObject); 
				return; 
			case KanbanmodelPackage.MECHANISM_ATTRIBUTE:
				sequence_MechanismAttribute(context, (MechanismAttribute) semanticObject); 
				return; 
			case KanbanmodelPackage.MODEL_BUILDER:
				sequence_ModelBuilder(context, (ModelBuilder) semanticObject); 
				return; 
			case KanbanmodelPackage.NUM_EXPRESSION:
				sequence_NumExpression(context, (NumExpression) semanticObject); 
				return; 
			case KanbanmodelPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case KanbanmodelPackage.PROCESS:
				sequence_Process(context, (datasem.xtext.kanban.domainmodel.kanbanmodel.Process) semanticObject); 
				return; 
			case KanbanmodelPackage.PROCESS_ATTRIBUTE:
				sequence_ProcessAttribute(context, (ProcessAttribute) semanticObject); 
				return; 
			case KanbanmodelPackage.PROCESS_MODEL:
				sequence_ProcessModel(context, (ProcessModel) semanticObject); 
				return; 
			case KanbanmodelPackage.RESOURCE_ALLOCATION:
				sequence_ResourceAllocation(context, (ResourceAllocation) semanticObject); 
				return; 
			case KanbanmodelPackage.RESOURCE_ALLOCATION_RULE_TYPE:
				sequence_ResourceAllocationRuleType(context, (ResourceAllocationRuleType) semanticObject); 
				return; 
			case KanbanmodelPackage.RESOURCE_OUTSOURCING:
				sequence_ResourceOutsourcing(context, (ResourceOutsourcing) semanticObject); 
				return; 
			case KanbanmodelPackage.RESOURCE_OUTSOURCING_RULE_TYPE:
				sequence_ResourceOutsourcingRuleType(context, (ResourceOutsourcingRuleType) semanticObject); 
				return; 
			case KanbanmodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case KanbanmodelPackage.SERVICE_PROVIDER:
				sequence_ServiceProvider(context, (ServiceProvider) semanticObject); 
				return; 
			case KanbanmodelPackage.SKILL:
				sequence_Skill(context, (Skill) semanticObject); 
				return; 
			case KanbanmodelPackage.SYSTEM_LIBRARIES:
				sequence_SystemLibraries(context, (SystemLibraries) semanticObject); 
				return; 
			case KanbanmodelPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case KanbanmodelPackage.TRANSITION_TYPE:
				sequence_TransitionType(context, (TransitionType) semanticObject); 
				return; 
			case KanbanmodelPackage.USER_LIBRARIES:
				sequence_UserLibraries(context, (UserLibraries) semanticObject); 
				return; 
			case KanbanmodelPackage.VALUE_FUNCTION:
				sequence_ValueFunction(context, (ValueFunction) semanticObject); 
				return; 
			case KanbanmodelPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_ACCEPTANCE:
				sequence_WIAcceptance(context, (WIAcceptance) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_ACCEPTANCE_RULE_TYPE:
				sequence_WIAcceptanceRuleType(context, (WIAcceptanceRuleType) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_ASSIGNMENT:
				sequence_WIAssignment(context, (WIAssignment) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_ASSIGNMENT_RULE_TYPE:
				sequence_WIAssignmentRuleType(context, (WIAssignmentRuleType) semanticObject); 
				return; 
			case KanbanmodelPackage.WIN_REPLICATION:
				sequence_WINReplication(context, (WINReplication) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_SELECTION:
				sequence_WISelection(context, (WISelection) semanticObject); 
				return; 
			case KanbanmodelPackage.WI_SELECTION_RULE_TYPE:
				sequence_WISelectionRuleType(context, (WISelectionRuleType) semanticObject); 
				return; 
			case KanbanmodelPackage.WORK_ITEM:
				sequence_WorkItem(context, (WorkItem) semanticObject); 
				return; 
			case KanbanmodelPackage.WORK_ITEM_NETWORK:
				sequence_WorkItemNetwork(context, (WorkItemNetwork) semanticObject); 
				return; 
			case KanbanmodelPackage.WORK_ITEM_TYPE:
				sequence_WorkItemType(context, (WorkItemType) semanticObject); 
				return; 
			case KanbanmodelPackage.WORK_SOURCE:
				sequence_WorkSource(context, (WorkSource) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((isVariable?='Variable:' variable=[Variable|ID]) | value=Parameter)
	 */
	protected void sequence_AbstractParameter(EObject context, AbstractParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_AgentRoleType(EObject context, AgentRoleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? number=AbstractParameter skillSet+=Skill*)
	 */
	protected void sequence_Asset(EObject context, Asset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (triggered+=[WorkItem|ID]+ atProgress=DOUBLE? onProbability=DOUBLE?)
	 */
	protected void sequence_CausalTrigger(EObject context, CausalTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? disruptive?='TRUE'?)
	 */
	protected void sequence_ClassOfService(EObject context, ClassOfService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ConditionType(EObject context, ConditionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ConditionType|ID] operator=Operator value=Parameter)
	 */
	protected void sequence_Condition(EObject context, Condition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.CONDITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.CONDITION__TYPE));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.CONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.CONDITION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.CONDITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.CONDITION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConditionAccess().getTypeConditionTypeIDTerminalRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getConditionAccess().getOperatorOperatorParserRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((isNormal?='Normal' | isUniform?='Uniform' | isExponential?='Exponential') parameters+=AbstractParameter*)
	 */
	protected void sequence_Distribution(EObject context, Distribution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_EventType(EObject context, EventType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (conditions+=Condition+ transitions+=Transition+)
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         Path=QualifiedName? 
	 *         Variables+=Variable* 
	 *         ServiceProviders+=ServiceProvider+ 
	 *         WorkSources+=WorkSource+ 
	 *         WorkItemNetworks+=WorkItemNetwork+ 
	 *         WINReplications+=WINReplication+ 
	 *         Indicators+=ID*
	 *     )
	 */
	protected void sequence_ExperimentModel(EObject context, ExperimentModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=INT? 
	 *         name=ID 
	 *         description=STRING? 
	 *         (
	 *             WIAcceptanceRule=WIAcceptance 
	 *             WISelectionRule=WISelection 
	 *             WIAssignmentRule=WIAssignment 
	 *             ResourceAllocationRule=ResourceAllocation 
	 *             ResourceOutsourcingRule=ResourceOutsourcing
	 *         )? 
	 *         Mechanisms+=Mechanism+ 
	 *         Processes+=Process+
	 *     )
	 */
	protected void sequence_GovernanceStrategy(EObject context, GovernanceStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attribute=STRING value=Parameter)
	 */
	protected void sequence_MechanismAttribute(EObject context, MechanismAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MECHANISM_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MECHANISM_ATTRIBUTE__ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getAttributeSTRINGTerminalRuleCall_0_0(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=Parameter description=STRING? attributes+=MechanismAttribute*)
	 */
	protected void sequence_Mechanism(EObject context, Mechanism semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID Description=STRING SystemLibraries=SystemLibraries UserLibraries=UserLibraries ExperimentModel=ExperimentModel)
	 */
	protected void sequence_ModelBuilder(EObject context, ModelBuilder semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__NAME));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__DESCRIPTION));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__SYSTEM_LIBRARIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__SYSTEM_LIBRARIES));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelBuilderAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelBuilderAccess().getDescriptionSTRINGTerminalRuleCall_3_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getModelBuilderAccess().getSystemLibrariesSystemLibrariesParserRuleCall_4_0(), semanticObject.getSystemLibraries());
		feeder.accept(grammarAccess.getModelBuilderAccess().getUserLibrariesUserLibrariesParserRuleCall_5_0(), semanticObject.getUserLibraries());
		feeder.accept(grammarAccess.getModelBuilderAccess().getExperimentModelExperimentModelParserRuleCall_6_0(), semanticObject.getExperimentModel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (numValue=DOUBLE | (distribution?='Random.' numDist=Distribution))
	 */
	protected void sequence_NumExpression(EObject context, NumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         equalTo?='==' | 
	 *         largerThan?='>' | 
	 *         smallerThan?='<' | 
	 *         largerOrEqualTo?='>=' | 
	 *         smallerOrEqualTo?='<=' | 
	 *         notEqualTo?='!='
	 *     )
	 */
	protected void sequence_Operator(EObject context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attribute=STRING value=Parameter)
	 */
	protected void sequence_ProcessAttribute(EObject context, ProcessAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.PROCESS_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.PROCESS_ATTRIBUTE__ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.PROCESS_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.PROCESS_ATTRIBUTE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcessAttributeAccess().getAttributeSTRINGTerminalRuleCall_0_0(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getProcessAttributeAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING? events+=Event+)
	 */
	protected void sequence_ProcessModel(EObject context, ProcessModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=Parameter description=STRING? attributes+=ProcessAttribute*)
	 */
	protected void sequence_Process(EObject context, datasem.xtext.kanban.domainmodel.kanbanmodel.Process semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ResourceAllocationRuleType(EObject context, ResourceAllocationRuleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ResourceAllocationRuleType|ID] description=STRING?)
	 */
	protected void sequence_ResourceAllocation(EObject context, ResourceAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ResourceOutsourcingRuleType(EObject context, ResourceOutsourcingRuleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ResourceOutsourcingRuleType|ID] description=STRING?)
	 */
	protected void sequence_ResourceOutsourcing(EObject context, ResourceOutsourcing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=INT? 
	 *         name=ID 
	 *         description=STRING? 
	 *         assignTo+=[ServiceProvider|ID]* 
	 *         outsourceFrom+=[ServiceProvider|ID]* 
	 *         teamService=[Service|ID] 
	 *         governanceStrategy=[GovernanceStrategy|ID]? 
	 *         resources+=Asset*
	 *     )
	 */
	protected void sequence_ServiceProvider(EObject context, ServiceProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING?)
	 */
	protected void sequence_Service(EObject context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (service=[Service|ID] efficiency=NumExpression)
	 */
	protected void sequence_Skill(EObject context, Skill semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.SKILL__SERVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.SKILL__SERVICE));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.SKILL__EFFICIENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.SKILL__EFFICIENCY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSkillAccess().getServiceServiceIDTerminalRuleCall_1_0_1(), semanticObject.getService());
		feeder.accept(grammarAccess.getSkillAccess().getEfficiencyNumExpressionParserRuleCall_3_0(), semanticObject.getEfficiency());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         EventTypes+=EventType+ 
	 *         ConditionTypes+=ConditionType+ 
	 *         TransitionTypes+=TransitionType+ 
	 *         WIAcceptanceRuleTypes+=WIAcceptanceRuleType+ 
	 *         WISelectionRuleTypes+=WISelectionRuleType+ 
	 *         WIAssignmentRuleTypes+=WIAssignmentRuleType+ 
	 *         ResourceAllocationRuleTypes+=ResourceAllocationRuleType+ 
	 *         ResourceOutsourcingRuleTypes+=ResourceOutsourcingRuleType+ 
	 *         ProcessModels+=ProcessModel+ 
	 *         ValueFunctions+=ValueFunction+
	 *     )
	 */
	protected void sequence_SystemLibraries(EObject context, SystemLibraries semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_TransitionType(EObject context, TransitionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[TransitionType|ID] value=Parameter)
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.TRANSITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.TRANSITION__TYPE));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.TRANSITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.TRANSITION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTransitionAccess().getTypeTransitionTypeIDTerminalRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getTransitionAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (WorkItemTypes+=WorkItemType+ ClassOfServices+=ClassOfService+ Services+=Service+ GovernanceStrategies+=GovernanceStrategy+)
	 */
	protected void sequence_UserLibraries(EObject context, UserLibraries semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ValueFunction(EObject context, ValueFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (typeInteger?='INT:' intValue=INT) | 
	 *             (typeDouble?='DOUBLE:' doubleValue=DOUBLE) | 
	 *             (typeString?='STRING:' stringValue=STRING) | 
	 *             (typeDistribution?='Distribution:' distrbution=Distribution) | 
	 *             (typeStrategy?='Strategy:' strategy=[GovernanceStrategy|ID])
	 *         )
	 *     )
	 */
	protected void sequence_Variable(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_WIAcceptanceRuleType(EObject context, WIAcceptanceRuleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[WIAcceptanceRuleType|ID] description=STRING? backlogQLimit=INT? readyQLimit=INT?)
	 */
	protected void sequence_WIAcceptance(EObject context, WIAcceptance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_WIAssignmentRuleType(EObject context, WIAssignmentRuleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[WIAssignmentRuleType|ID] description=STRING?)
	 */
	protected void sequence_WIAssignment(EObject context, WIAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (workItemNetwork=[WorkItemNetwork|ID] numReplications=INT)
	 */
	protected void sequence_WINReplication(EObject context, WINReplication semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK));
			if(transientValues.isValueTransient(semanticObject, KanbanmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KanbanmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWINReplicationAccess().getWorkItemNetworkWorkItemNetworkIDTerminalRuleCall_1_0_1(), semanticObject.getWorkItemNetwork());
		feeder.accept(grammarAccess.getWINReplicationAccess().getNumReplicationsINTTerminalRuleCall_3_0(), semanticObject.getNumReplications());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_WISelectionRuleType(EObject context, WISelectionRuleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[WISelectionRuleType|ID] description=STRING?)
	 */
	protected void sequence_WISelection(EObject context, WISelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? workItems+=WorkItem+)
	 */
	protected void sequence_WorkItemNetwork(EObject context, WorkItemNetwork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? hierarchy=INT?)
	 */
	protected void sequence_WorkItemType(EObject context, WorkItemType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=INT? 
	 *         name=ID 
	 *         description=STRING? 
	 *         type=[WorkItemType|ID] 
	 *         (hasPredecessors?='Predecessors' pTasks+=[WorkItem|ID]+)? 
	 *         (isAggregationNode?='Subtasks' sTasks+=[WorkItem|ID]+)? 
	 *         causalTriggers+=CausalTrigger* 
	 *         requiredServices+=[Service|ID]+ 
	 *         efforts=NumExpression? 
	 *         maturityLevels=[AbstractParameter|ID]? 
	 *         uncertainty=[AbstractParameter|ID]? 
	 *         risk=[AbstractParameter|ID]? 
	 *         changePropagation=STRING? 
	 *         value=NumExpression? 
	 *         classOfService=[ClassOfService|ID]? 
	 *         workSource=[WorkSource|ID]? 
	 *         arrivalTime=INT? 
	 *         dueDate=INT?
	 *     )
	 */
	protected void sequence_WorkItem(EObject context, WorkItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? assignTo+=[ServiceProvider|ID]* assignmentRule=WIAssignment?)
	 */
	protected void sequence_WorkSource(EObject context, WorkSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
