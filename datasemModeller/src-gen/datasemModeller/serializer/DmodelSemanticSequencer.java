/*
 * generated by Xtext
 */
package datasemModeller.serializer;

import com.google.inject.Inject;
import datasemModeller.dmodel.AbstractParameter;
import datasemModeller.dmodel.Asset;
import datasemModeller.dmodel.Distribution;
import datasemModeller.dmodel.DmodelPackage;
import datasemModeller.dmodel.ExperimentModel;
import datasemModeller.dmodel.ExperimentVariable;
import datasemModeller.dmodel.GovernanceStrategy;
import datasemModeller.dmodel.Impact;
import datasemModeller.dmodel.Mechanism;
import datasemModeller.dmodel.MechanismAttribute;
import datasemModeller.dmodel.ModelBuilder;
import datasemModeller.dmodel.NumExpression;
import datasemModeller.dmodel.PullStrategy;
import datasemModeller.dmodel.RequiredService;
import datasemModeller.dmodel.Service;
import datasemModeller.dmodel.ServiceProvider;
import datasemModeller.dmodel.ServiceProviderType;
import datasemModeller.dmodel.Skill;
import datasemModeller.dmodel.UserLibraries;
import datasemModeller.dmodel.WINReplication;
import datasemModeller.dmodel.WorkItem;
import datasemModeller.dmodel.WorkItemNetwork;
import datasemModeller.dmodel.WorkItemType;
import datasemModeller.services.DmodelGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DmodelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DmodelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DmodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DmodelPackage.ABSTRACT_PARAMETER:
				sequence_AbstractParameter(context, (AbstractParameter) semanticObject); 
				return; 
			case DmodelPackage.ASSET:
				sequence_Asset(context, (Asset) semanticObject); 
				return; 
			case DmodelPackage.DISTRIBUTION:
				sequence_Distribution(context, (Distribution) semanticObject); 
				return; 
			case DmodelPackage.EXPERIMENT_MODEL:
				sequence_ExperimentModel(context, (ExperimentModel) semanticObject); 
				return; 
			case DmodelPackage.EXPERIMENT_VARIABLE:
				sequence_ExperimentVariable(context, (ExperimentVariable) semanticObject); 
				return; 
			case DmodelPackage.GOVERNANCE_STRATEGY:
				sequence_GovernanceStrategy(context, (GovernanceStrategy) semanticObject); 
				return; 
			case DmodelPackage.IMPACT:
				sequence_Impact(context, (Impact) semanticObject); 
				return; 
			case DmodelPackage.MECHANISM:
				sequence_Mechanism(context, (Mechanism) semanticObject); 
				return; 
			case DmodelPackage.MECHANISM_ATTRIBUTE:
				sequence_MechanismAttribute(context, (MechanismAttribute) semanticObject); 
				return; 
			case DmodelPackage.MODEL_BUILDER:
				sequence_ModelBuilder(context, (ModelBuilder) semanticObject); 
				return; 
			case DmodelPackage.NUM_EXPRESSION:
				sequence_NumExpression(context, (NumExpression) semanticObject); 
				return; 
			case DmodelPackage.PULL_STRATEGY:
				sequence_PullStrategy(context, (PullStrategy) semanticObject); 
				return; 
			case DmodelPackage.REQUIRED_SERVICE:
				sequence_RequiredService(context, (RequiredService) semanticObject); 
				return; 
			case DmodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case DmodelPackage.SERVICE_PROVIDER:
				sequence_ServiceProvider(context, (ServiceProvider) semanticObject); 
				return; 
			case DmodelPackage.SERVICE_PROVIDER_TYPE:
				sequence_ServiceProviderType(context, (ServiceProviderType) semanticObject); 
				return; 
			case DmodelPackage.SKILL:
				sequence_Skill(context, (Skill) semanticObject); 
				return; 
			case DmodelPackage.USER_LIBRARIES:
				sequence_UserLibraries(context, (UserLibraries) semanticObject); 
				return; 
			case DmodelPackage.WIN_REPLICATION:
				sequence_WINReplication(context, (WINReplication) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM:
				sequence_WorkItem(context, (WorkItem) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM_NETWORK:
				sequence_WorkItemNetwork(context, (WorkItemNetwork) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM_TYPE:
				sequence_WorkItemType(context, (WorkItemType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractParameter returns AbstractParameter
	 *
	 * Constraint:
	 *     ((isVariable?='var:' variable=[ExperimentVariable|ID]) | value=Parameter)
	 */
	protected void sequence_AbstractParameter(ISerializationContext context, AbstractParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Asset returns Asset
	 *
	 * Constraint:
	 *     (name=ID number=AbstractParameter (skillSet+=Skill skillSet+=Skill*)? id=INT?)
	 */
	protected void sequence_Asset(ISerializationContext context, Asset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Distribution returns Distribution
	 *
	 * Constraint:
	 *     ((isNormal?='Normal' | isUniform?='Uniform' | isExponential?='Exponential') parameters+=Parameter parameters+=Parameter*)
	 */
	protected void sequence_Distribution(ISerializationContext context, Distribution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentModel returns ExperimentModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         ExperimentVariables+=ExperimentVariable* 
	 *         ServiceProviders+=ServiceProvider+ 
	 *         WorkItemNetworks+=WorkItemNetwork+ 
	 *         WINReplications+=WINReplication+
	 *     )
	 */
	protected void sequence_ExperimentModel(ISerializationContext context, ExperimentModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentVariable returns ExperimentVariable
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (boolean?='boolean' booleanValue=BOOLEAN) | 
	 *             (num?='num' numValue=Number) | 
	 *             (distribution?='Random.' numDist=Distribution) | 
	 *             (string?='string' stringValue=STRING) | 
	 *             (strategy?='GovernanceStrategy' strategyValue=GovernanceStrategy)
	 *         )
	 *     )
	 */
	protected void sequence_ExperimentVariable(ISerializationContext context, ExperimentVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GovernanceStrategy returns GovernanceStrategy
	 *
	 * Constraint:
	 *     (name=ID pullStrategy=PullStrategy)
	 */
	protected void sequence_GovernanceStrategy(ISerializationContext context, GovernanceStrategy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.GOVERNANCE_STRATEGY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.GOVERNANCE_STRATEGY__NAME));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.GOVERNANCE_STRATEGY__PULL_STRATEGY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.GOVERNANCE_STRATEGY__PULL_STRATEGY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGovernanceStrategyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGovernanceStrategyAccess().getPullStrategyPullStrategyParserRuleCall_2_0(), semanticObject.getPullStrategy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Impact returns Impact
	 *
	 * Constraint:
	 *     (impactWI=[WorkItem|ID] likelihood=AbstractParameter risk=AbstractParameter)
	 */
	protected void sequence_Impact(ISerializationContext context, Impact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__IMPACT_WI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__IMPACT_WI));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__LIKELIHOOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__LIKELIHOOD));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__RISK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__RISK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpactAccess().getImpactWIWorkItemIDTerminalRuleCall_0_0_1(), semanticObject.getImpactWI());
		feeder.accept(grammarAccess.getImpactAccess().getLikelihoodAbstractParameterParserRuleCall_2_0(), semanticObject.getLikelihood());
		feeder.accept(grammarAccess.getImpactAccess().getRiskAbstractParameterParserRuleCall_4_0(), semanticObject.getRisk());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MechanismAttribute returns MechanismAttribute
	 *
	 * Constraint:
	 *     (name=ID value=Parameter)
	 */
	protected void sequence_MechanismAttribute(ISerializationContext context, MechanismAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mechanism returns Mechanism
	 *
	 * Constraint:
	 *     (name=ID value=Parameter (attributes+=MechanismAttribute attributes+=MechanismAttribute*)?)
	 */
	protected void sequence_Mechanism(ISerializationContext context, Mechanism semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelBuilder returns ModelBuilder
	 *
	 * Constraint:
	 *     (name=ID UserLibraries=UserLibraries ExperimentModel=ExperimentModel)
	 */
	protected void sequence_ModelBuilder(ISerializationContext context, ModelBuilder semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__NAME));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelBuilderAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelBuilderAccess().getUserLibrariesUserLibrariesParserRuleCall_2_0(), semanticObject.getUserLibraries());
		feeder.accept(grammarAccess.getModelBuilderAccess().getExperimentModelExperimentModelParserRuleCall_3_0(), semanticObject.getExperimentModel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumExpression returns NumExpression
	 *
	 * Constraint:
	 *     (numValue=Number | (distribution?='Random.' numDist=Distribution))
	 */
	protected void sequence_NumExpression(ISerializationContext context, NumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PullStrategy returns PullStrategy
	 *
	 * Constraint:
	 *     mechanisms+=Mechanism+
	 */
	protected void sequence_PullStrategy(ISerializationContext context, PullStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequiredService returns RequiredService
	 *
	 * Constraint:
	 *     (serviceType=[Service|ID] efforts=AbstractParameter)
	 */
	protected void sequence_RequiredService(ISerializationContext context, RequiredService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__SERVICE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__SERVICE_TYPE));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__EFFORTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__EFFORTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequiredServiceAccess().getServiceTypeServiceIDTerminalRuleCall_1_0_1(), semanticObject.getServiceType());
		feeder.accept(grammarAccess.getRequiredServiceAccess().getEffortsAbstractParameterParserRuleCall_3_0(), semanticObject.getEfforts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ServiceProviderType returns ServiceProviderType
	 *
	 * Constraint:
	 *     (id=INT? name=ID hierarchy=INT?)
	 */
	protected void sequence_ServiceProviderType(ISerializationContext context, ServiceProviderType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceProvider returns ServiceProvider
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[ServiceProviderType|ID]? 
	 *         (assignTo+=[ServiceProvider|ID] assignTo+=[ServiceProvider|ID]*)? 
	 *         governanceStrategy=[GovernanceStrategy|ID]? 
	 *         resources+=Asset* 
	 *         id=INT?
	 *     )
	 */
	protected void sequence_ServiceProvider(ISerializationContext context, ServiceProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID hierarchy=INT? id=INT?)
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Skill returns Skill
	 *
	 * Constraint:
	 *     (service=[Service|ID] efficiency=AbstractParameter)
	 */
	protected void sequence_Skill(ISerializationContext context, Skill semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.SKILL__SERVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.SKILL__SERVICE));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.SKILL__EFFICIENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.SKILL__EFFICIENCY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkillAccess().getServiceServiceIDTerminalRuleCall_1_0_1(), semanticObject.getService());
		feeder.accept(grammarAccess.getSkillAccess().getEfficiencyAbstractParameterParserRuleCall_3_0(), semanticObject.getEfficiency());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UserLibraries returns UserLibraries
	 *
	 * Constraint:
	 *     (ServiceProviderTypes+=ServiceProviderType+ WorkItemTypes+=WorkItemType+ Services+=Service+ GovernanceStrategies+=GovernanceStrategy*)
	 */
	protected void sequence_UserLibraries(ISerializationContext context, UserLibraries semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WINReplication returns WINReplication
	 *
	 * Constraint:
	 *     (workItemNetwork=[WorkItemNetwork|ID] numReplications=INT)
	 */
	protected void sequence_WINReplication(ISerializationContext context, WINReplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK));
			if (transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWINReplicationAccess().getWorkItemNetworkWorkItemNetworkIDTerminalRuleCall_0_0_1(), semanticObject.getWorkItemNetwork());
		feeder.accept(grammarAccess.getWINReplicationAccess().getNumReplicationsINTTerminalRuleCall_2_0(), semanticObject.getNumReplications());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WorkItemNetwork returns WorkItemNetwork
	 *
	 * Constraint:
	 *     (name=ID workItems+=WorkItem+ id=INT?)
	 */
	protected void sequence_WorkItemNetwork(ISerializationContext context, WorkItemNetwork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkItemType returns WorkItemType
	 *
	 * Constraint:
	 *     (name=ID hierarchy=INT? id=INT?)
	 */
	protected void sequence_WorkItemType(ISerializationContext context, WorkItemType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkItem returns WorkItem
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[WorkItemType|ID]? 
	 *         (hasPredecessors?='prerequisites' pTasks+=[WorkItem|ID] pTasks+=[WorkItem|ID]*)? 
	 *         (
	 *             (
	 *                 hasSubtasks?='decomposites' 
	 *                 sTasks+=[WorkItem|ID] 
	 *                 sTasks+=[WorkItem|ID]* 
	 *                 (requiredAnalysis+=RequiredService requiredAnalysis+=RequiredService*)?
	 *             ) | 
	 *             ((requiredAnalysis+=RequiredService requiredAnalysis+=RequiredService*)? requiredServices+=RequiredService requiredServices+=RequiredService*)
	 *         )? 
	 *         (hasImpacts?='impacts' impacts+=Impact impacts+=Impact*)? 
	 *         value=NumExpression? 
	 *         arrivalTime=INT? 
	 *         duration=INT? 
	 *         id=INT?
	 *     )
	 */
	protected void sequence_WorkItem(ISerializationContext context, WorkItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
