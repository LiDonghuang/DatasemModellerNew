/*
 * generated by Xtext
 */
package datasemModeller.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import datasemModeller.dmodel.AbstractParameter;
import datasemModeller.dmodel.AbstractType;
import datasemModeller.dmodel.Action;
import datasemModeller.dmodel.ActionStatement;
import datasemModeller.dmodel.Agent;
import datasemModeller.dmodel.AssertStatement;
import datasemModeller.dmodel.Asset;
import datasemModeller.dmodel.Attribute;
import datasemModeller.dmodel.AttributeValue;
import datasemModeller.dmodel.ChangeStateStatement;
import datasemModeller.dmodel.ClassAttributes;
import datasemModeller.dmodel.ClassOfService;
import datasemModeller.dmodel.Condition;
import datasemModeller.dmodel.ContractNetProtocol;
import datasemModeller.dmodel.DeclarationStatement;
import datasemModeller.dmodel.Distribution;
import datasemModeller.dmodel.Division;
import datasemModeller.dmodel.DmodelPackage;
import datasemModeller.dmodel.ExperimentModel;
import datasemModeller.dmodel.ExperimentVariable;
import datasemModeller.dmodel.Factor;
import datasemModeller.dmodel.ForExpression;
import datasemModeller.dmodel.GovernanceStrategy;
import datasemModeller.dmodel.IfExpression;
import datasemModeller.dmodel.Impact;
import datasemModeller.dmodel.Mechanism;
import datasemModeller.dmodel.MechanismAttribute;
import datasemModeller.dmodel.Method;
import datasemModeller.dmodel.Minus;
import datasemModeller.dmodel.ModelBuilder;
import datasemModeller.dmodel.Multiply;
import datasemModeller.dmodel.NumExpression;
import datasemModeller.dmodel.Operator;
import datasemModeller.dmodel.Plus;
import datasemModeller.dmodel.ProcessModel;
import datasemModeller.dmodel.PullStrategy;
import datasemModeller.dmodel.PushStrategy;
import datasemModeller.dmodel.RequiredService;
import datasemModeller.dmodel.RoleBehavior;
import datasemModeller.dmodel.Service;
import datasemModeller.dmodel.ServiceProvider;
import datasemModeller.dmodel.ServiceProviderType;
import datasemModeller.dmodel.Skill;
import datasemModeller.dmodel.State;
import datasemModeller.dmodel.Statement;
import datasemModeller.dmodel.Task;
import datasemModeller.dmodel.UserLibraries;
import datasemModeller.dmodel.ValueFunction;
import datasemModeller.dmodel.VarExpression;
import datasemModeller.dmodel.Variable;
import datasemModeller.dmodel.WINReplication;
import datasemModeller.dmodel.WhileExpression;
import datasemModeller.dmodel.WorkItem;
import datasemModeller.dmodel.WorkItemNetwork;
import datasemModeller.dmodel.WorkItemType;
import datasemModeller.dmodel.WorkSource;
import datasemModeller.services.DmodelGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DmodelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DmodelGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == DmodelPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case DmodelPackage.ABSTRACT_PARAMETER:
				sequence_AbstractParameter(context, (AbstractParameter) semanticObject); 
				return; 
			case DmodelPackage.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case DmodelPackage.ACTION:
				sequence_Action(context, (Action) semanticObject); 
				return; 
			case DmodelPackage.ACTION_STATEMENT:
				sequence_ActionStatement(context, (ActionStatement) semanticObject); 
				return; 
			case DmodelPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case DmodelPackage.ASSERT_STATEMENT:
				sequence_AssertStatement(context, (AssertStatement) semanticObject); 
				return; 
			case DmodelPackage.ASSET:
				sequence_Asset(context, (Asset) semanticObject); 
				return; 
			case DmodelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case DmodelPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case DmodelPackage.CHANGE_STATE_STATEMENT:
				sequence_ChangeStateStatement(context, (ChangeStateStatement) semanticObject); 
				return; 
			case DmodelPackage.CLASS_ATTRIBUTES:
				sequence_ClassAttributes(context, (ClassAttributes) semanticObject); 
				return; 
			case DmodelPackage.CLASS_OF_SERVICE:
				sequence_ClassOfService(context, (ClassOfService) semanticObject); 
				return; 
			case DmodelPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case DmodelPackage.CONTRACT_NET_PROTOCOL:
				sequence_ContractNetProtocol(context, (ContractNetProtocol) semanticObject); 
				return; 
			case DmodelPackage.DECLARATION_STATEMENT:
				sequence_DeclarationStatement(context, (DeclarationStatement) semanticObject); 
				return; 
			case DmodelPackage.DISTRIBUTION:
				sequence_Distribution(context, (Distribution) semanticObject); 
				return; 
			case DmodelPackage.DIVISION:
				sequence_Term(context, (Division) semanticObject); 
				return; 
			case DmodelPackage.EXPERIMENT_MODEL:
				sequence_ExperimentModel(context, (ExperimentModel) semanticObject); 
				return; 
			case DmodelPackage.EXPERIMENT_VARIABLE:
				sequence_ExperimentVariable(context, (ExperimentVariable) semanticObject); 
				return; 
			case DmodelPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case DmodelPackage.FOR_EXPRESSION:
				sequence_ForExpression(context, (ForExpression) semanticObject); 
				return; 
			case DmodelPackage.GOVERNANCE_STRATEGY:
				sequence_GovernanceStrategy(context, (GovernanceStrategy) semanticObject); 
				return; 
			case DmodelPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case DmodelPackage.IMPACT:
				sequence_Impact(context, (Impact) semanticObject); 
				return; 
			case DmodelPackage.MECHANISM:
				sequence_Mechanism(context, (Mechanism) semanticObject); 
				return; 
			case DmodelPackage.MECHANISM_ATTRIBUTE:
				sequence_MechanismAttribute(context, (MechanismAttribute) semanticObject); 
				return; 
			case DmodelPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case DmodelPackage.MINUS:
				sequence_Expression(context, (Minus) semanticObject); 
				return; 
			case DmodelPackage.MODEL_BUILDER:
				sequence_ModelBuilder(context, (ModelBuilder) semanticObject); 
				return; 
			case DmodelPackage.MULTIPLY:
				sequence_Term(context, (Multiply) semanticObject); 
				return; 
			case DmodelPackage.NUM_EXPRESSION:
				sequence_NumExpression(context, (NumExpression) semanticObject); 
				return; 
			case DmodelPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case DmodelPackage.PLUS:
				sequence_Expression(context, (Plus) semanticObject); 
				return; 
			case DmodelPackage.PROCESS_MODEL:
				sequence_ProcessModel(context, (ProcessModel) semanticObject); 
				return; 
			case DmodelPackage.PULL_STRATEGY:
				sequence_PullStrategy(context, (PullStrategy) semanticObject); 
				return; 
			case DmodelPackage.PUSH_STRATEGY:
				sequence_PushStrategy(context, (PushStrategy) semanticObject); 
				return; 
			case DmodelPackage.REQUIRED_SERVICE:
				sequence_RequiredService(context, (RequiredService) semanticObject); 
				return; 
			case DmodelPackage.ROLE_BEHAVIOR:
				sequence_RoleBehavior(context, (RoleBehavior) semanticObject); 
				return; 
			case DmodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case DmodelPackage.SERVICE_PROVIDER:
				sequence_ServiceProvider(context, (ServiceProvider) semanticObject); 
				return; 
			case DmodelPackage.SERVICE_PROVIDER_TYPE:
				sequence_ServiceProviderType(context, (ServiceProviderType) semanticObject); 
				return; 
			case DmodelPackage.SKILL:
				sequence_Skill(context, (Skill) semanticObject); 
				return; 
			case DmodelPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case DmodelPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case DmodelPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case DmodelPackage.USER_LIBRARIES:
				sequence_UserLibraries(context, (UserLibraries) semanticObject); 
				return; 
			case DmodelPackage.VALUE_FUNCTION:
				sequence_ValueFunction(context, (ValueFunction) semanticObject); 
				return; 
			case DmodelPackage.VAR_EXPRESSION:
				sequence_VarExpression(context, (VarExpression) semanticObject); 
				return; 
			case DmodelPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case DmodelPackage.WIN_REPLICATION:
				sequence_WINReplication(context, (WINReplication) semanticObject); 
				return; 
			case DmodelPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM:
				sequence_WorkItem(context, (WorkItem) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM_NETWORK:
				sequence_WorkItemNetwork(context, (WorkItemNetwork) semanticObject); 
				return; 
			case DmodelPackage.WORK_ITEM_TYPE:
				sequence_WorkItemType(context, (WorkItemType) semanticObject); 
				return; 
			case DmodelPackage.WORK_SOURCE:
				sequence_WorkSource(context, (WorkSource) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((isVariable?='var:' variable=[ExperimentVariable|ID]) | value=Parameter)
	 */
	protected void sequence_AbstractParameter(EObject context, AbstractParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type | (listType?='List' type=Type) | (mapType?='Map' keyType=Type valueType=Type))
	 */
	protected void sequence_AbstractType(EObject context, AbstractType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (action=[Action|ID] inputs+=VarExpression+)
	 */
	protected void sequence_ActionStatement(EObject context, ActionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID inputs+=Variable? inputs+=Variable*)
	 */
	protected void sequence_Action(EObject context, Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID attributeValues+=AttributeValue*)
	 */
	protected void sequence_Agent(EObject context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (input=VarExpression value=Expression)
	 */
	protected void sequence_AssertStatement(EObject context, AssertStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.ASSERT_STATEMENT__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.ASSERT_STATEMENT__INPUT));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.ASSERT_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.ASSERT_STATEMENT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssertStatementAccess().getInputVarExpressionParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getAssertStatementAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID number=AbstractParameter (skillSet+=Skill skillSet+=Skill*)? id=INT?)
	 */
	protected void sequence_Asset(EObject context, Asset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attribute=[Attribute|ID] value=Parameter)
	 */
	protected void sequence_AttributeValue(EObject context, AttributeValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.ATTRIBUTE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.ATTRIBUTE_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAttributeValueAccess().getAttributeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getAttributeValueAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=AbstractType name=ID default=Parameter?)
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     targetState=[State|ID]
	 */
	protected void sequence_ChangeStateStatement(EObject context, ChangeStateStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.CHANGE_STATE_STATEMENT__TARGET_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.CHANGE_STATE_STATEMENT__TARGET_STATE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChangeStateStatementAccess().getTargetStateStateIDTerminalRuleCall_1_0_1(), semanticObject.getTargetState());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     agentAttributes+=Attribute+
	 */
	protected void sequence_ClassAttributes(EObject context, ClassAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? priority=INT? disruptive=BOOLEAN?)
	 */
	protected void sequence_ClassOfService(EObject context, ClassOfService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ((subjective=VarExpression operator=Operator objective=Expression) | (subjective=VarExpression operator=Operator objective=Expression)) 
	 *         ((hasAnd?='and' andCondition=Condition) | (hasOr?='or' orCondition=Condition))?
	 *     )
	 */
	protected void sequence_Condition(EObject context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (mechanisms+=Mechanism+ variables+=Variable* roleBehaviors+=RoleBehavior+)
	 */
	protected void sequence_ContractNetProtocol(EObject context, ContractNetProtocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((variable=DeclarationStatement_DeclarationStatement_1 value=Expression?) | variable=DeclarationStatement_DeclarationStatement_1)
	 */
	protected void sequence_DeclarationStatement(EObject context, DeclarationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((isNormal?='Normal' | isUniform?='Uniform' | isExponential?='Exponential') parameters+=Parameter parameters+=Parameter*)
	 */
	protected void sequence_Distribution(EObject context, Distribution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         Path=QualifiedName? 
	 *         ExperimentVariables+=ExperimentVariable* 
	 *         ServiceProviders+=ServiceProvider+ 
	 *         WorkSources+=WorkSource+ 
	 *         WorkItemNetworks+=WorkItemNetwork+ 
	 *         WINReplications+=WINReplication+ 
	 *         Indicators+=ID*
	 *     )
	 */
	protected void sequence_ExperimentModel(EObject context, ExperimentModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (boolean?='boolean' booleanValue=BOOLEAN) | 
	 *             (num?='num' numValue=Number) | 
	 *             (distribution?='Random.' numDist=Distribution) | 
	 *             (string?='string' stringValue=STRING) | 
	 *             (strategy?='GovernanceStrategy' strategyValue=GovernanceStrategy)
	 *         )
	 *     )
	 */
	protected void sequence_ExperimentVariable(EObject context, ExperimentVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Expression_Minus_1_0_1_0 right=Term)
	 */
	protected void sequence_Expression(EObject context, Minus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MINUS__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MINUS__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Expression_Plus_1_0_0_0 right=Term)
	 */
	protected void sequence_Expression(EObject context, Plus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.PLUS__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.PLUS__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (number=Number | variable=VarExpression | string=STRING | boolean=BOOLEAN | expression=Expression)
	 */
	protected void sequence_Factor(EObject context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (object=VarExpression set=VarExpression statements+=Statement*)
	 */
	protected void sequence_ForExpression(EObject context, ForExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (pull?='Pull' description=STRING? pullStrategy=PullStrategy) | 
	 *             (push?='Push' description=STRING? pushStrategy=PushStrategy) | 
	 *             (cnp?='CNP' description=STRING? contractNetProtocal=ContractNetProtocol)
	 *         ) 
	 *         processes+=[ProcessModel|ID]+
	 *     )
	 */
	protected void sequence_GovernanceStrategy(EObject context, GovernanceStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Condition statements+=Statement* ((hasElseIf?='if' elseIf=IfExpression) | elses+=Statement*)?)
	 */
	protected void sequence_IfExpression(EObject context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (impactWI=[WorkItem|ID] likelihood=AbstractParameter risk=AbstractParameter)
	 */
	protected void sequence_Impact(EObject context, Impact semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__IMPACT_WI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__IMPACT_WI));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__LIKELIHOOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__LIKELIHOOD));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.IMPACT__RISK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.IMPACT__RISK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImpactAccess().getImpactWIWorkItemIDTerminalRuleCall_0_0_1(), semanticObject.getImpactWI());
		feeder.accept(grammarAccess.getImpactAccess().getLikelihoodAbstractParameterParserRuleCall_2_0(), semanticObject.getLikelihood());
		feeder.accept(grammarAccess.getImpactAccess().getRiskAbstractParameterParserRuleCall_4_0(), semanticObject.getRisk());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attribute=STRING value=Parameter)
	 */
	protected void sequence_MechanismAttribute(EObject context, MechanismAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MECHANISM_ATTRIBUTE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getAttributeSTRINGTerminalRuleCall_0_0(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getMechanismAttributeAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=Parameter description=STRING? attributes+=MechanismAttribute*)
	 */
	protected void sequence_Mechanism(EObject context, Mechanism semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID functionMethod?='(' inputs+=Parameter? inputs+=Parameter*)
	 */
	protected void sequence_Method(EObject context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID Description=STRING UserLibraries=UserLibraries ExperimentModel=ExperimentModel)
	 */
	protected void sequence_ModelBuilder(EObject context, ModelBuilder semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__NAME));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__DESCRIPTION));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__USER_LIBRARIES));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MODEL_BUILDER__EXPERIMENT_MODEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelBuilderAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelBuilderAccess().getDescriptionSTRINGTerminalRuleCall_3_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getModelBuilderAccess().getUserLibrariesUserLibrariesParserRuleCall_4_0(), semanticObject.getUserLibraries());
		feeder.accept(grammarAccess.getModelBuilderAccess().getExperimentModelExperimentModelParserRuleCall_5_0(), semanticObject.getExperimentModel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (numValue=Number | (distribution?='Random.' numDist=Distribution))
	 */
	protected void sequence_NumExpression(EObject context, NumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         equalTo?='==' | 
	 *         largerThan?='>' | 
	 *         smallerThan?='<' | 
	 *         largerOrEqualTo?='>=' | 
	 *         smallerOrEqualTo?='<=' | 
	 *         notEqualTo?='!='
	 *     )
	 */
	protected void sequence_Operator(EObject context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID actions+=Action* states+=State+)
	 */
	protected void sequence_ProcessModel(EObject context, ProcessModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     mechanisms+=Mechanism+
	 */
	protected void sequence_PullStrategy(EObject context, PullStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     mechanisms+=Mechanism+
	 */
	protected void sequence_PushStrategy(EObject context, PushStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (serviceType=[Service|ID] efforts=AbstractParameter)
	 */
	protected void sequence_RequiredService(EObject context, RequiredService semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__SERVICE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__SERVICE_TYPE));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__EFFORTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.REQUIRED_SERVICE__EFFORTS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRequiredServiceAccess().getServiceTypeServiceIDTerminalRuleCall_1_0_1(), semanticObject.getServiceType());
		feeder.accept(grammarAccess.getRequiredServiceAccess().getEffortsAbstractParameterParserRuleCall_3_0(), semanticObject.getEfforts());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID actions+=Action* states+=State+)
	 */
	protected void sequence_RoleBehavior(EObject context, RoleBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? hierarchy=INT?)
	 */
	protected void sequence_ServiceProviderType(EObject context, ServiceProviderType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[ServiceProviderType|ID]? 
	 *         (assignTo+=[ServiceProvider|ID] assignTo+=[ServiceProvider|ID]*)? 
	 *         (outsourceFrom+=[ServiceProvider|ID] outsourceFrom+=[ServiceProvider|ID]*)? 
	 *         governanceStrategy=[GovernanceStrategy|ID]? 
	 *         resources+=Asset* 
	 *         id=INT?
	 *     )
	 */
	protected void sequence_ServiceProvider(EObject context, ServiceProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (description=STRING? hierarchy=INT?)? id=INT?)
	 */
	protected void sequence_Service(EObject context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (service=[Service|ID] efficiency=AbstractParameter)
	 */
	protected void sequence_Skill(EObject context, Skill semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.SKILL__SERVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.SKILL__SERVICE));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.SKILL__EFFICIENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.SKILL__EFFICIENCY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSkillAccess().getServiceServiceIDTerminalRuleCall_1_0_1(), semanticObject.getService());
		feeder.accept(grammarAccess.getSkillAccess().getEfficiencyAbstractParameterParserRuleCall_3_0(), semanticObject.getEfficiency());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((backgroundState?='backgroundState' name=ID) | (name=ID statements+=Statement*))
	 */
	protected void sequence_State(EObject context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (isAction?='Do' actionStatement=ActionStatement) | 
	 *         (isChangeState?='->' changeStateStatement=ChangeStateStatement) | 
	 *         (isDeclaration?='var' declarationStatement=DeclarationStatement) | 
	 *         (isIfExpression?='if' ifExpression=IfExpression) | 
	 *         (isForExpression?='for' forExpression=ForExpression) | 
	 *         (isWhileExpression?='while' whileExpression=WhileExpression) | 
	 *         assertStatement=AssertStatement
	 *     )
	 */
	protected void sequence_Statement(EObject context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID attributeValues+=AttributeValue*)
	 */
	protected void sequence_Task(EObject context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Term_Division_1_0_1_0 right=Factor)
	 */
	protected void sequence_Term(EObject context, Division semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.DIVISION__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.DIVISION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTermAccess().getDivisionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Term_Multiply_1_0_0_0 right=Factor)
	 */
	protected void sequence_Term(EObject context, Multiply semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MULTIPLY__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.MULTIPLY__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTermAccess().getMultiplyLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ServiceProviderTypes+=ServiceProviderType+ 
	 *         WorkItemTypes+=WorkItemType+ 
	 *         ProcessModels+=ProcessModel* 
	 *         ClassOfServices+=ClassOfService* 
	 *         Services+=Service* 
	 *         GovernanceStrategies+=GovernanceStrategy*
	 *     )
	 */
	protected void sequence_UserLibraries(EObject context, UserLibraries semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ValueFunction(EObject context, ValueFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((self?='self' | context?='context' | variable=QualifiedName) methods+=Method*)
	 */
	protected void sequence_VarExpression(EObject context, VarExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=AbstractType name=ID)
	 */
	protected void sequence_Variable(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (workItemNetwork=[WorkItemNetwork|ID] numReplications=INT)
	 */
	protected void sequence_WINReplication(EObject context, WINReplication semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__WORK_ITEM_NETWORK));
			if(transientValues.isValueTransient(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmodelPackage.Literals.WIN_REPLICATION__NUM_REPLICATIONS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWINReplicationAccess().getWorkItemNetworkWorkItemNetworkIDTerminalRuleCall_1_0_1(), semanticObject.getWorkItemNetwork());
		feeder.accept(grammarAccess.getWINReplicationAccess().getNumReplicationsINTTerminalRuleCall_3_0(), semanticObject.getNumReplications());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Condition statements+=Statement*)
	 */
	protected void sequence_WhileExpression(EObject context, WhileExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING? workItems+=WorkItem+ id=INT?)
	 */
	protected void sequence_WorkItemNetwork(EObject context, WorkItemNetwork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=INT? name=ID description=STRING? hierarchy=INT?)
	 */
	protected void sequence_WorkItemType(EObject context, WorkItemType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[WorkItemType|ID]? 
	 *         description=STRING? 
	 *         (hasPredecessors?='prerequisites' pTasks+=[WorkItem|ID] pTasks+=[WorkItem|ID]*)? 
	 *         (
	 *             (hasSubtasks?='decomposites' sTasks+=[WorkItem|ID] sTasks+=[WorkItem|ID]* requiredAnalysis+=RequiredService requiredAnalysis+=RequiredService*)? | 
	 *             ((requiredAnalysis+=RequiredService requiredAnalysis+=RequiredService*)? requiredServices+=RequiredService requiredServices+=RequiredService*)
	 *         ) 
	 *         maturityLevels=AbstractParameter? 
	 *         uncertainty=AbstractParameter? 
	 *         (hasImpacts?='impacts' impacts+=Impact impacts+=Impact*)? 
	 *         value=NumExpression? 
	 *         risk=AbstractParameter? 
	 *         classOfService=[ClassOfService|ID]? 
	 *         workSource=[WorkSource|ID]? 
	 *         arrivalTime=INT? 
	 *         dueDate=INT? 
	 *         id=INT?
	 *     )
	 */
	protected void sequence_WorkItem(EObject context, WorkItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING? assignTo+=[ServiceProvider|ID]*)
	 */
	protected void sequence_WorkSource(EObject context, WorkSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
